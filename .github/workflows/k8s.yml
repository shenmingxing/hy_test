# This workflow will build and push a new container image to Amazon ECR,
# and then will deploy a new task definition to Amazon ECS, when there is a push to the "main" branch.
#
# To use this workflow, you will need to complete the following set-up steps:
#
# 1. Create an ECR repository to store your images.
#    For example: `aws ecr create-repository --repository-name my-ecr-repo --region us-east-2`.
#    Replace the value of the `ECR_REPOSITORY` environment variable in the workflow below with your repository's name.
#    Replace the value of the `AWS_REGION` environment variable in the workflow below with your repository's region.
#
# 2. Create an ECS task definition, an ECS cluster, and an ECS service.
#    For example, follow the Getting Started guide on the ECS console:
#      https://us-east-2.console.aws.amazon.com/ecs/home?region=us-east-2#/firstRun
#    Replace the value of the `ECS_SERVICE` environment variable in the workflow below with the name you set for the Amazon ECS service.
#    Replace the value of the `ECS_CLUSTER` environment variable in the workflow below with the name you set for the cluster.
#
# 3. Store your ECS task definition as a JSON file in your repository.
#    The format should follow the output of `aws ecs register-task-definition --generate-cli-skeleton`.
#    Replace the value of the `ECS_TASK_DEFINITION` environment variable in the workflow below with the path to the JSON file.
#    Replace the value of the `CONTAINER_NAME` environment variable in the workflow below with the name of the container
#    in the `containerDefinitions` section of the task definition.
#
# 4. Store an IAM user access key in GitHub Actions secrets named `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`.
#    See the documentation for each action used below for the recommended IAM policies for this IAM user,
#    and best practices on handling the access key credentials.

name: Deploy to Amazon ECS
on:
  push:
    tags:
      - test-v1.*
      - dev-v1.*
      - prod-v1.*

    branches:
      - prod
      - dev
      - test
      - main




permissions:
  contents: read

jobs:
  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Get branch names
        id: branch-names
        uses: tj-actions/branch-names@v8
        with:
          strip_tag_prefix: v # Optionally strip the leading `v` from the tag.

      - name: current branch name
        run: |
          echo "${{ steps.branch-names.outputs.current_branch }}"
        # Outputs: "main" the default branch.


      - name: Running on the default branch.
        if: steps.branch-names.outputs.is_default == 'true'
        run: |
          echo "Running on default: ${{ steps.branch-names.outputs.current_branch }}"
        # Outputs: "Running on default: main".

      - name: Running on the default branch (i.e non tag based branch).
        if: steps.branch-names.outputs.is_tag == 'false' && steps.branch-names.outputs.is_default == 'true'
        run: |
          echo "Running on branch: ${{ steps.branch-names.outputs.current_branch }}"
        # Outputs: "Running on branch: main".

      - name: Get Ref brach name
        run: |
          echo "${{ steps.branch-names.outputs.ref_branch }}"
        #  Outputs: "main"



      - name: Running on a tag branch.
        if: steps.branch-names.outputs.is_tag == 'true'
        run: |
          echo "Running on: ${{ steps.branch-names.outputs.tag }}"
        # Outputs: "Running on: 0.0.1".

      - name: Get the current tag
        if: steps.branch-names.outputs.is_tag == 'true'  # Replaces: startsWith(github.ref, 'refs/tags/')
        run: |
          echo "${{ steps.branch-names.outputs.tag }}"
        # Outputs: "0.0.1"

#      - name:  Prints the current branch name
#        run: echo "${GITHUB_REF##*/}"
#        env:
#          GITHUB_BRANCH: ${{ github.ref }}





#      - name: Check tag name and branch
#        run: |
#          tag_name=$(echo $GITHUB_REF | cut -d '/' -f 3)
#          branch=$(echo $GITHUB_REF | cut -d '/' -f 2)
#           echo "github_ref : $GITHUB_REF, The tag name is: $tag_name, branch is : $branch"
#          if [ "${tag_name:0:8}" == "release-" ] && [ $branch == "main" ]; then
#              echo "This is a release tag on main branch."
#              # 执行部署到生产环境的操作
#              echo "Deploying to production environment"
#              # 这里可添加具体的部署命令，如scp、rsync等用于将构建好的项目传输到目标环境
#          else
#              echo "This is not a release tag on main branch."
#          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "image=$ECR_REGISTRY/game-rpc:$IMAGE_TAG"
          docker build -t $ECR_REGISTRY/game-rpc:$IMAGE_TAG .          
          docker push $ECR_REGISTRY/game-rpc:$IMAGE_TAG
